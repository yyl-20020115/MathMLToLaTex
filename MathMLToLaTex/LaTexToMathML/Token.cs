using System.Collections.Generic;

namespace MaTeX.LaTexToMathML;

public enum DisplayStyle
{
    Block,
    Inline
}
public enum Variant
{
    Normal,
    Italic,
    Bold,
    BoldItalic,
    DoubleStruck,
    BoldFraktur,
    Script,
    BoldScript,
    Fraktur,
    SansSerif,
    BoldSansSerif,
    SansSerifItalic,
    SansSerifBoldItalic,
    Monospace,
}

public enum LineThickness {
    Thin,
    Medium,
    Thick,
    Length,
}

public enum ColumnAlign
{
    Center,
    Left,
    Right,
}
public static class CharUtils
{
    public static bool IsAsciiLetter(this char c) => c >= 0 && c <= 0xff && char.IsLetter(c);
    public static bool IsAsciiDigit(this char c) => c >= 0 && c <= 0xff && char.IsDigit(c);

    public static bool IsSpace(this char c) => c == ' ' || c == '\t' || c == '\n' || c == '\r';
}
public static class AttributeUtils
{
    public static string ToString(this ColumnAlign align) => align switch
    {
        ColumnAlign.Center => "",
        ColumnAlign.Left => " columnalign=left",
        ColumnAlign.Right => " columnalign=right",
        _ => ""
    };
    public static string ToString(this LineThickness thickness, byte value = 0) => thickness switch
    {
        LineThickness.Thin => $" linethickness=\"thin\"",
        LineThickness.Medium => "",
        LineThickness.Thick => $" linethickness=\"thick\"",
        LineThickness.Length => $" linethickness=\"{value}\"",
        _ => ""
    };
    public static string ToString(this Variant variant) => variant switch
    {
        Variant.Normal => "normal",
        Variant.Italic => "italic",
        Variant.Bold => "bold",
        Variant.BoldItalic => "bold-italic",
        Variant.DoubleStruck => "double-struck",
        Variant.BoldFraktur => "bold-fraktur",
        Variant.Script => "script",
        Variant.BoldScript => "bold-script",
        Variant.Fraktur => "fraktur",
        Variant.SansSerif => "sans-serif",
        Variant.BoldSansSerif => "bold-sans-serif",
        Variant.SansSerifItalic => "sans-serif-italic",
        Variant.SansSerifBoldItalic => "sans-serif-bold-italic",
        Variant.Monospace => "monospace",
        _ => ""
    };
}
public abstract record class Token
{
    public override string ToString() => this.GetType().Name;

    public record class Illegal(char c) : Token { public readonly char c = c; }
    public record class EOF : Token { }
    public record class Begin : Token { }
    public record class End : Token { }
    public record class Ampersand : Token { }
    public record class NewLine : Token { }
    public record class Left : Token { }
    public record class Right : Token { }
    public record class Middle : Token { }
    public record class Paren(string s) : Token { public readonly string s = s; }
    public record class LBrace : Token { }
    public record class RBrace : Token { }
    public record class Frac : Token { }
    public record class Underscore : Token { }
    public record class Circumflex : Token { }
    public record class Binom(DisplayStyle? s = null) : Token { public readonly DisplayStyle? s = s; }
    public record class Overset : Token { }
    public record class Underset : Token { }
    public record class Overbrace(char c) : Token { public readonly char c = c; }
    public record class Underbrace(char c) : Token { public readonly char c = c; }
    public record class Sqrt : Token { }
    public record class Integral(char c) : Token { public readonly char c = c; }
    public record class Lim(string s) : Token { public readonly string s = s; }
    public record class Space(float f) : Token { public readonly float f = f; }
    public record class Style(Variant v) : Token { public readonly Variant v = v; }
    public record class Big(string s) : Token { public readonly string s = s; }
    public record class Over(char c, bool Accent) : Token { public readonly char c = c; public readonly bool Accent = Accent; }
    public record class Under(char c, bool Accent) : Token { public readonly char c = c; public readonly bool Accent = Accent; }
    public record class Operator(char c) : Token { public readonly char c = c; }
    public record class BigOp(char c) : Token { public readonly char c = c; }
    public record class Letter(char c, Variant v) : Token { public readonly char c = c; public readonly Variant v = v; }
    public record class Number(String s) : Token { public readonly string s = s; }
    public record class Function(string s) : Token { public readonly string s = s; }
    public record class OperatorName : Token { }
    public record class Slashed() : Token { }
    public record class Text : Token { }
    public record class Command(string s) : Token { public readonly string s = s; }

    public static bool ActOnDigit(Token t) => t is Sqrt or Frac or Binom or Style;
    public static Token FromCommand(string s) =>
        s switch
        {
            "mathrm" => new Style(Variant.Normal),
            "textit" => new Style(Variant.Italic),
            "mathit" => new Style(Variant.Italic),
            "textbf" => new Style(Variant.Bold),
            "mathbf" => new Style(Variant.Bold),
            "bm" => new Style(Variant.BoldItalic),
            "symbf" => new Style(Variant.BoldItalic),
            "mathbb" => new Style(Variant.DoubleStruck),
            "mathfrak" => new Style(Variant.Fraktur),
            "mathscr" => new Style(Variant.Script),
            "mathsf" => new Style(Variant.SansSerif),
            "texttt" => new Style(Variant.Monospace),
            "boldsymbol" => new Style(Variant.BoldItalic),
            "text" => new Text(),
            "sqrt" => new Sqrt(),
            "frac" => new Frac(),
            "left" => new Left(),
            "right" => new Right(),
            "middle" => new Middle(),
            "begin" => new Begin(),
            "end" => new End(),
            "\\" => new NewLine(),
            "binom" => new Binom(),
            "tbinom" => new Binom(DisplayStyle.Inline),
            "dbinom" => new Binom(DisplayStyle.Block),
            "overset" => new Overset(),
            "underset" => new Underset(),
            "overbrace" => new Overbrace('\u23de'),
            "underbrace" => new Underbrace('\u23df'),
            "overparen" => new Overbrace('\u23dc'),
            "underparen" => new Underbrace('\u23dd'),
            "overbracket" => new Overbrace('\u23b4'),
            "underbracket" => new Underbrace('\u23b5'),
            "!" => new Space(-3.0f / 18.0f),
            "," => new Space(3.0f / 18.0f),
            ":" => new Space(4.0f / 18.0f),
            ";" => new Space(5.0f / 18.0f),
            " " => new Space(1.0f),
            "quad" => new Space(1.0f),
            "qquad" => new Space(2.0f),
            "langle" => new Paren("&lang;"),
            "rangle" => new Paren("&rang;"),
            "{" => new Paren("{"),
            "}" => new Paren("}"),
            "lceil" => new Paren("⌈"),
            "rceil" => new Paren("⌉"),
            "lfloor" => new Paren("⌊"),
            "rfloor" => new Paren("⌋"),
            "lgroup" => new Paren("⦗"),
            "rgroup" => new Paren("⦘"),
            "llbracket" => new Paren("⟦"),
            "rrbracket" => new Paren("⟧"),
            "lim" => new Lim("lim"),
            "liminf" => new Lim("lim inf"),
            "limsup" => new Lim("lim sup"),
            "min" => new Lim("min"),
            "max" => new Lim("max"),
            "inf" => new Lim("inf"),
            "sup" => new Lim("sup"),
            "int" => new Integral('∫'),
            "iint" => new Integral('∬'),
            "iiint" => new Integral('∭'),
            "oint" => new Integral('∮'),
            "dot" => new Over('\u02d9', true),
            "ddot" => new Over('¨', true),
            "bar" => new Over('¯', true),
            "hat" => new Over('^', true),
            "check" => new Over('ˇ', true),
            "breve" => new Over('˘', true),
            "acute" => new Over('´', true),
            "grave" => new Over('`', true),
            "tilde" => new Over('~', true),
            "vec" => new Over('→', true),
            "overline" => new Over('_', true),
            "underline" => new Under('_', true),
            "widehat" => new Over('^', true),
            "widetilde" => new Over('~', true),
            "overrightarrow" => new Over('→', true),
            "overleftarrow" => new Over('←', true),
            "sum" => new BigOp('∑'),
            "prod" => new BigOp('∏'),
            "coprod" => new BigOp('∐'),
            "bigcap" => new BigOp('⋂'),
            "bigcup" => new BigOp('⋃'),
            "bigsqcup" => new BigOp('⨆'),
            "bigvee" => new BigOp('⋁'),
            "bigwedge" => new BigOp('⋀'),
            "bigodot" => new BigOp('⨀'),
            "bitotimes" => new BigOp('⨂'),
            "bigoplus" => new BigOp('⨁'),
            "biguplus" => new BigOp('⨄'),
            "bigl" => new Big("1.2em"),
            "bigr" => new Big("1.2em"),
            "Bigl" => new Big("1.623em"),
            "Bigr" => new Big("1.623em"),
            "biggl" => new Big("2.047em"),
            "biggr" => new Big("2.047em"),
            "Biggl" => new Big("2.470em"),
            "Biggr" => new Big("2.470em"),
            "sin" => new Function("sin"),
            "cos" => new Function("cos"),
            "tan" => new Function("tan"),
            "csc" => new Function("csc"),
            "sec" => new Function("sec"),
            "cot" => new Function("cot"),
            "arcsin" => new Function("arcsin"),
            "arccos" => new Function("arccos"),
            "arctan" => new Function("arctan"),
            "sinh" => new Function("sinh"),
            "cosh" => new Function("cosh"),
            "tanh" => new Function("tanh"),
            "coth" => new Function("coth"),
            "exp" => new Function("exp"),
            "ln" => new Function("ln"),
            "log" => new Function("log"),
            "erf" => new Function("erf"),
            "erfc" => new Function("erfc"),
            "arg" => new Function("arg"),
            "ker" => new Function("ker"),
            "dim" => new Function("dim"),
            "det" => new Function("det"),
            "wp" => new Function("℘"),
            "operatorname" => new OperatorName(),
            "Alpha" => new Letter('Α', Variant.Normal),
            "alpha" => new Letter('α', Variant.Italic),
            "Beta" => new Letter('Β', Variant.Normal),
            "beta" => new Letter('β', Variant.Italic),
            "Gamma" => new Letter('Γ', Variant.Normal),
            "gamma" => new Letter('γ', Variant.Italic),
            "digamma" => new Letter('ϝ', Variant.Italic),
            "Delta" => new Letter('Δ', Variant.Normal),
            "delta" => new Letter('δ', Variant.Italic),
            "Epsilon" => new Letter('Ε', Variant.Normal),
            "epsilon" => new Letter('ϵ', Variant.Italic),
            "varepsilon" => new Letter('ε', Variant.Italic),
            "Zeta" => new Letter('Ζ', Variant.Normal),
            "zeta" => new Letter('ζ', Variant.Italic),
            "Eta" => new Letter('Η', Variant.Normal),
            "eta" => new Letter('η', Variant.Italic),
            "Theta" => new Letter('Θ', Variant.Normal),
            "theta" => new Letter('θ', Variant.Italic),
            "vartheta" => new Letter('ϑ', Variant.Italic),
            "Iota" => new Letter('Ι', Variant.Normal),
            "iota" => new Letter('ι', Variant.Italic),
            "Kappa" => new Letter('Κ', Variant.Normal),
            "kappa" => new Letter('κ', Variant.Italic),
            "Lambda" => new Letter('Λ', Variant.Normal),
            "lambda" => new Letter('λ', Variant.Italic),
            "Mu" => new Letter('Μ', Variant.Normal),
            "mu" => new Letter('μ', Variant.Italic),
            "Nu" => new Letter('Ν', Variant.Normal),
            "nu" => new Letter('ν', Variant.Italic),
            "Xi" => new Letter('Ξ', Variant.Normal),
            "xi" => new Letter('ξ', Variant.Italic),
            "Omicron" => new Letter('Ο', Variant.Normal),
            "omicron" => new Letter('ο', Variant.Italic),
            "Pi" => new Letter('Π', Variant.Normal),
            "pi" => new Letter('π', Variant.Italic),
            "varpi" => new Letter('ϖ', Variant.Italic),
            "Rho" => new Letter('Ρ', Variant.Normal),
            "rho" => new Letter('ρ', Variant.Italic),
            "varrho" => new Letter('ϱ', Variant.Italic),
            "Sigma" => new Letter('Σ', Variant.Normal),
            "sigma" => new Letter('σ', Variant.Italic),
            "varsigma" => new Letter('ς', Variant.Italic),
            "Tau" => new Letter('Τ', Variant.Normal),
            "tau" => new Letter('τ', Variant.Italic),
            "Upsilon" => new Letter('Υ', Variant.Normal),
            "upsilon" => new Letter('υ', Variant.Italic),
            "Phi" => new Letter('Φ', Variant.Normal),
            "phi" => new Letter('ϕ', Variant.Italic),
            "varphi" => new Letter('φ', Variant.Italic),
            "Chi" => new Letter('Χ', Variant.Normal),
            "chi" => new Letter('χ', Variant.Italic),
            "Psi" => new Letter('Ψ', Variant.Normal),
            "psi" => new Letter('ψ', Variant.Italic),
            "Omega" => new Letter('Ω', Variant.Normal),
            "omega" => new Letter('ω', Variant.Italic),
            "aleph" => new Letter('ℵ', Variant.Normal),
            "beth" => new Letter('ℶ', Variant.Normal),
            "gimel" => new Letter('ℷ', Variant.Normal),
            "daleth" => new Letter('ℸ', Variant.Normal),
            "A" => new Letter('Å', Variant.Normal),
            "a" => new Letter('å', Variant.Normal),
            "AE" => new Letter('Æ', Variant.Normal),
            "ae" => new Letter('æ', Variant.Normal),
            "DH" => new Letter('Ð', Variant.Normal),
            "dh" => new Letter('ð', Variant.Normal),
            "dj" => new Letter('đ', Variant.Normal),
            "L" => new Letter('Ł', Variant.Normal),
            "l" => new Letter('ł', Variant.Normal),
            "NG" => new Letter('Ŋ', Variant.Normal),
            "ng" => new Letter('ŋ', Variant.Normal),
            "O" => new Letter('Ø', Variant.Normal),
            "o" => new Letter('ø', Variant.Normal),
            "OE" => new Letter('Œ', Variant.Normal),
            "oe" => new Letter('œ', Variant.Normal),
            "ss" => new Letter('ß', Variant.Normal),
            "TH" => new Letter('Þ', Variant.Normal),
            "th" => new Letter('þ', Variant.Normal),
            "imath" => new Letter('ı', Variant.Italic),
            "jmath" => new Letter('ȷ', Variant.Italic),
            "ell" => new Letter('ℓ', Variant.Italic),
            "hbar" => new Letter('ℏ', Variant.Italic),
            "hslash" => new Letter('ℏ', Variant.Italic),
            "infty" => new Letter('∞', Variant.Normal),
            "mho" => new Letter('℧', Variant.Normal),
            "Finv" => new Letter('Ⅎ', Variant.Normal),
            "Re" => new Letter('ℜ', Variant.Normal),
            "Im" => new Letter('ℑ', Variant.Normal),
            "complement" => new Letter('∁', Variant.Normal),
            "emptyset" => new Letter('∅', Variant.Normal),
            "therefore" => new Letter('∴', Variant.Normal),
            "because" => new Letter('∵', Variant.Normal),
            "Diamond" => new Letter('◊', Variant.Normal),
            "Box" => new Letter('◻', Variant.Normal),
            "triangle" => new Letter('△', Variant.Normal),
            "angle" => new Letter('∠', Variant.Normal),
            "dagger" => new Letter('†', Variant.Normal),
            "dag" => new Letter('†', Variant.Normal),
            "Dagger" => new Letter('‡', Variant.Normal),
            "ddag" => new Letter('‡', Variant.Normal),
            "And" => new Letter('&', Variant.Normal),
            "eth" => new Letter('ð', Variant.Normal),
            "S" => new Letter('§', Variant.Normal),
            "P" => new Letter('¶', Variant.Normal),
            "%" => new Letter('%', Variant.Normal),
            "_" => new Letter('_', Variant.Normal),
            "&" => new Letter('&', Variant.Normal),
            "#" => new Letter('#', Variant.Normal),
            "$" => new Letter('$', Variant.Normal),
            "copyright" => new Letter('©', Variant.Normal),
            "checkmark" => new Letter('✓', Variant.Normal),
            "circledR" => new Letter('Ⓡ', Variant.Normal),
            "maltese" => new Letter('✠', Variant.Normal),
            "colon" => new Letter(':', Variant.Normal),
            "bigtriangleup" => new Letter('△', Variant.Normal),
            "sphericalangle" => new Letter('∢', Variant.Normal),
            "square" => new Letter('□', Variant.Normal),
            "lozenge" => new Letter('◊', Variant.Normal),
            "diamondsuit" => new Letter('♢', Variant.Normal),
            "heartsuit" => new Letter('♡', Variant.Normal),
            "clubsuit" => new Letter('♣', Variant.Normal),
            "spadesuit" => new Letter('♠', Variant.Normal),
            "Game" => new Letter('⅁', Variant.Normal),
            "flat" => new Letter('♭', Variant.Normal),
            "natural" => new Letter('♮', Variant.Normal),
            "sharp" => new Letter('♯', Variant.Normal),
            "pounds" => new Letter('£', Variant.Normal),
            "textyen" => new Letter('¥', Variant.Normal),
            "euro" => new Letter('€', Variant.Normal),
            "rupee" => new Letter('₹', Variant.Normal),
            "sun" => new Letter('☼', Variant.Normal),
            "mercury" => new Letter('☿', Variant.Normal),
            "venus" => new Letter('♀', Variant.Normal),
            "earth" => new Letter('♁', Variant.Normal),
            "mars" => new Letter('♂', Variant.Normal),
            "jupiter" => new Letter('♃', Variant.Normal),
            "saturn" => new Letter('♄', Variant.Normal),
            "uranus" => new Letter('♅', Variant.Normal),
            "neptune" => new Letter('♆', Variant.Normal),
            "astrosun" => new Letter('☉', Variant.Normal),
            "ascnode" => new Letter('☊', Variant.Normal),
            "times" => new Operator('×'),
            "oplus" => new Operator('⊕'),
            "ominus" => new Operator('⊖'),
            "otimes" => new Operator('⊗'),
            "oslash" => new Operator('⊘'),
            "odot" => new Operator('⊙'),
            "bigcirc" => new Operator('◯'),
            "amalg" => new Operator('⨿'),
            "pm" => new Operator('±'),
            "mp" => new Operator('∓'),
            "cdot" => new Operator('·'),
            "cdots" => new Operator('⋯'),
            "vdots" => new Operator('⋮'),
            "ldots" => new Operator('…'),
            "ddots" => new Operator('⋱'),
            "circ" => new Operator('∘'),
            "bullet" => new Operator('∙'),
            "star" => new Operator('⋆'),
            "div" => new Operator('÷'),
            "lnot" => new Operator('¬'),
            "land" => new Operator('∧'),
            "lor" => new Operator('∨'),
            "sim" => new Operator('∼'),
            "simeq" => new Operator('≃'),
            "nsim" => new Operator('≁'),
            "cong" => new Operator('≅'),
            "approx" => new Operator('≈'),
            "ne" => new Operator('≠'),
            "neq" => new Operator('≠'),
            "equiv" => new Operator('≡'),
            "nequiv" => new Operator('≢'),
            "prec" => new Operator('≺'),
            "succ" => new Operator('≻'),
            "preceq" => new Operator('⪯'),
            "succeq" => new Operator('⪰'),
            "dashv" => new Operator('⊣'),
            "asymp" => new Operator('≍'),
            "doteq" => new Operator('≐'),
            "propto" => new Operator('∝'),
            "barwedge" => new Operator('⊼'),
            "ltimes" => new Operator('⋉'),
            "rtimes" => new Operator('⋊'),
            "Join" => new Operator('⋈'),
            "lhd" => new Operator('⊲'),
            "rhd" => new Operator('⊳'),
            "unlhd" => new Operator('⊴'),
            "unrhd" => new Operator('⊵'),
            "vee" => new Operator('∨'),
            "uplus" => new Operator('⊎'),
            "wedge" => new Operator('∧'),
            "boxdot" => new Operator('⊡'),
            "boxplus" => new Operator('⊞'),
            "boxminus" => new Operator('⊟'),
            "boxtimes" => new Operator('⊠'),
            "boxbox" => new Operator('⧈'),
            "boxslash" => new Operator('⧄'),
            "boxbslash" => new Operator('⧅'),
            "Cap" => new Operator('⋒'),
            "Cup" => new Operator('⋓'),
            "centerdot" => new Operator('∙'),
            "circledast" => new Operator('⊛'),
            "circledcirc" => new Operator('⊚'),
            "circleddash" => new Operator('⊝'),
            "curlyvee" => new Operator('⋎'),
            "curlywedge" => new Operator('⋏'),
            "dotplus" => new Operator('∔'),
            "intercal" => new Operator('⊺'),
            "divideontimes" => new Operator('⋇'),
            "leftthreetimes" => new Operator('⋋'),
            "rightthreetimes" => new Operator('⋌'),
            "smallsetminus" => new Operator('﹨'),
            "triangledown" => new Operator('▽'),
            "triangleleft" => new Operator('◁'),
            "triangleright" => new Operator('▷'),
            "vartriangle" => new Operator('△'),
            "veebar" => new Operator('⊻'),
            "cap" => new Operator('∩'),
            "cup" => new Operator('∪'),
            "mid" => new Operator('\u2223'),
            "nmid" => new Operator('\u2224'),
            "|" => new Paren("\u2225"),
            "parallel" => new Operator('∥'),
            "perp" => new Operator('⊥'),
            "forall" => new Operator('∀'),
            "exists" => new Operator('∃'),
            "nexists" => new Operator('∄'),
            "lt" => new Operator('<'),
            "gt" => new Operator('>'),
            "leq" => new Operator('≤'),
            "geq" => new Operator('≥'),
            "ll" => new Operator('≪'),
            "gg" => new Operator('≫'),
            "lessapprox" => new Operator('⪅'),
            "lesssim" => new Operator('≲'),
            "eqslantless" => new Operator('⪕'),
            "leqslant" => new Operator('⩽'),
            "leqq" => new Operator('≦'),
            "geqq" => new Operator('≧'),
            "geqslant" => new Operator('⩾'),
            "eqslantgtr" => new Operator('⪖'),
            "gtrsim" => new Operator('≳'),
            "gtrapprox" => new Operator('⪆'),
            "approxeq" => new Operator('≊'),
            "lessdot" => new Operator('⋖'),
            "lll" => new Operator('⋘'),
            "lessgtr" => new Operator('≶'),
            "lesseqgtr" => new Operator('⋚'),
            "lesseqqgtr" => new Operator('⪋'),
            "doteqdot" => new Operator('≑'),
            "risingdotseq" => new Operator('≓'),
            "leftarrow" => new Operator('←'),
            "gets" => new Operator('←'),
            "rightarrow" => new Operator('→'),
            "to" => new Operator('→'),
            "nleftarrow" => new Operator('↚'),
            "nrightarrow" => new Operator('↛'),
            "leftrightarrow" => new Operator('↔'),
            "nleftrightarrow" => new Operator('↮'),
            "longleftarrow" => new Operator('⟵'),
            "longrightarrow" => new Operator('⟶'),
            "longleftrightarrow" => new Operator('⟷'),
            "Leftarrow" => new Operator('⇐'),
            "Rightarrow" => new Operator('⇒'),
            "nLeftarrow" => new Operator('⇍'),
            "nRightarrow" => new Operator('⇏'),
            "Leftrightarrow" => new Operator('⇔'),
            "nLeftrightarrow" => new Operator('⇎'),
            "Longleftarrow" => new Operator('⟸'),
            "impliedby" => new Operator('⟸'),
            "Longrightarrow" => new Operator('⟹'),
            "implies" => new Operator('⟹'),
            "Longleftrightarrow" => new Operator('⟺'),
            "iff" => new Operator('⟺'),
            "uparrow" => new Operator('↑'),
            "downarrow" => new Operator('↓'),
            "updownarrow" => new Operator('↕'),
            "Uparrow" => new Operator('⇑'),
            "Downarrow" => new Operator('⇓'),
            "Updownarrow" => new Operator('⇕'),
            "nearrow" => new Operator('↗'),
            "searrow" => new Operator('↘'),
            "swarrow" => new Operator('↙'),
            "nwarrow" => new Operator('↖'),
            "rightharpoonup" => new Operator('⇀'),
            "rightharpoondown" => new Operator('⇁'),
            "leftharpoonup" => new Operator('↼'),
            "leftharpoondown" => new Operator('↽'),
            "upharpoonleft" => new Operator('↿'),
            "upharpoonright" => new Operator('↾'),
            "downharpoonleft" => new Operator('⇃'),
            "downharpoonright" => new Operator('⇂'),
            "rightleftharpoons" => new Operator('⇌'),
            "leftrightharpoons" => new Operator('⇋'),
            "curvearrowleft" => new Operator('↶'),
            "circlearrowleft" => new Operator('↺'),
            "Lsh" => new Operator('↰'),
            "upuparrows" => new Operator('⇈'),
            "rightrightarrows" => new Operator('⇉'),
            "rightleftarrows" => new Operator('⇄'),
            "Rrightarrow" => new Operator('⇛'),
            "rightarrowtail" => new Operator('↣'),
            "looparrowright" => new Operator('↬'),
            "curvearrowright" => new Operator('↷'),
            "circlearrowright" => new Operator('↻'),
            "Rsh" => new Operator('↱'),
            "downdownarrows" => new Operator('⇊'),
            "leftleftarrows" => new Operator('⇇'),
            "leftrightarrows" => new Operator('⇆'),
            "Lleftarrow" => new Operator('⇚'),
            "leftarrowtail" => new Operator('↢'),
            "looparrowleft" => new Operator('↫'),
            "mapsto" => new Operator('↦'),
            "longmapsto" => new Operator('⟼'),
            "hookrightarrow" => new Operator('↪'),
            "hookleftarrow" => new Operator('↩'),
            "multimap" => new Operator('⊸'),
            "leftrightsquigarrow" => new Operator('↭'),
            "rightsquigarrow" => new Operator('⇝'),
            "lightning" => new Operator('↯'),
            "Yleft" => new Operator('⤙'),
            "Yright" => new Operator('⤚'),
            "in" => new Operator('\u2208'),
            "ni" => new Operator('\u2209'),
            "notin" => new Operator('\u2209'),
            "subset" => new Operator('\u2282'),
            "supset" => new Operator('\u2283'),
            "subseteq" => new Operator('\u2286'),
            "supseteq" => new Operator('\u2287'),
            "nsubseteq" => new Operator('\u2288'),
            "nsupseteq" => new Operator('\u2289'),
            "subsetneq" => new Operator('\u228a'),
            "supsetneq" => new Operator('\u228b'),
            "sqsubset" => new Operator('⊏'),
            "sqsubseteq" => new Operator('⊑'),
            "sqsupset" => new Operator('⊐'),
            "sqsupseteq" => new Operator('⊒'),
            "sqcap" => new Operator('⊓'),
            "sqcup" => new Operator('⊔'),
            "setminus" => new Operator('∖'),
            "partial" => new Operator('∂'),
            "nabla" => new Operator('∇'),
            "smile" => new Operator('⌣'),
            "from" => new Operator('⌢'),
            "wr" => new Operator('≀'),
            "bot" => new Operator('⊥'),
            "top" => new Operator('⊤'),
            "vdash" => new Operator('⊢'),
            "vDash" => new Operator('⊨'),
            "Vdash" => new Operator('⊩'),
            "models" => new Operator('⊨'),
            "slashed" => new Slashed(),
            _ => new Command(s),
        };
}

// <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
//   <semantics>
//     <mrow>
//         <mi>a</mi>
//         <mrow class="MJX-TeXAtom-OPEN"><mo maxsize="2.470em" minsize="2.470em">(</mo></ mrow>
//         <mi>b</mi>
//         <mrow class="MJX-TeXAtom-OPEN"><mo maxsize="2.047em" minsize="2.047em">(</mo></mrow>
//         <mi>c</mi>
//         <mrow class="MJX-TeXAtom-OPEN"><mo maxsize="1.623em" minsize="1.623em">(</mo></mrow>
//         <mi>d</mi>
//         <mrow class="MJX-TeXAtom-OPEN"><mo maxsize="1.2em" minsize="1.2em">(</mo></mrow>
//         <mi>e</mi>
//         <mo stretchy="false">(</mo>
//         <mi>f</mi>
//         <mo>+</mo>
//         <mi>g</mi>
//         <mo stretchy="false">)</mo>
//         <mrow class="MJX-TeXAtom-CLOSE"><mo maxsize="1.2em" minsize="1.2em">)</mo></mrow>
//         <mrow class="MJX-TeXAtom-CLOSE"><mo maxsize="1.623em" minsize="1.623em">)</mo></mrow>
//         <mrow class="MJX-TeXAtom-CLOSE"><mo maxsize="2.047em" minsize="2.047em">)</mo></mrow>
//         <mrow class="MJX-TeXAtom-CLOSE"><mo maxsize="2.470em" minsize="2.470em">)</mo></mrow>
//   </semantics>
// </math>
